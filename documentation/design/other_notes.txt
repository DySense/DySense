Need to address data:
    0) Acquisition from
        - sensor (i.e. a class that inherits from SensorBase)
        - Another computer (e.g. another DySense program or a computer running ROS)
    1) Logging - to a csv file.
    2) Access - for downloading logs.
    3) Distribution for
        - visualization
        - passing to another DySense program to monitor from another computer.
        - passing to another program to use data in realtime.
        - using with a 3rd party library (ros) this should have a way to notify that something is wrong.

Every sensor should be testable using a test file.

Can forward sensor output stream onto OTHER sensor clients.  This happens 

Could make filename pattern settable for (e.g name_type_date_time)
        
Could either go ROS -> DySense or DySense -> ROS

For distributed features:
    - RemoteSensorClient > inherits from SensorClient so it can be used the same... but instead gets its data, messages and status from RemoteSensorController.
    - SensorControllerServer > Sits and waits for new connections.  When it gets one it creates a new thread that initially sends all sensor clients and then can queue up new 'changes' to be sent.   
    - SensorControllerClient > New one created for each server you want to connect to.  Receives updates and passes them to presenter and can also get commands from presenter.  Should have the same interface as normal SensorController so presenter can have a list of sensor_controllers and just pass them off to all of them.
    
The server protocol starts with either 'add', 'remove', 'update' and then sends a sensor client.  Needs to use JSON or something to serialize the objects.  The RSC client can send back commands or changes for individual sensors. For example '2', 'setting', 'name', 'new_name1'.  So an RSC client needs a reference to the SensorController on that computer.  

Have a remote_sensor_controller and remote_sensor_clients that interface with other sensor_controllers.  For example there's a Remote title bar where you can add a 'remote' where you give it an IP address and port and Name.   This goes out and connects to another remote_sensor_controller (RSC).  An RSC acts as both a server and a client.  It has a minimum of 2 threads.  One that binds on a port and waits for new connections.  The other waits.

For getting data from another computer should be able to add a remote computer.
The just adds a 
        
Use single underscore prefix for private fields or methods
def method1()
    ''' dsldkfjdsf ''' is a docstring - use to describe methods, classes and sometimes files.
    code is here
    
Named tuple - tuple + object syntax
x[0] to get first element of tuple or x.some_name to get first element

(windows - shift right click "copy as path")
filepath - C:\Users\Kyle\Documents\DySense\documentation\design\sensor_meta_file.txt
directory - C:\Users\Kyle\Documents\DySense\documentation\design\
filename - sensor_meta_file.txt
filename_no_ext = sensor_meta_file
ext - .txt
To split a filepath:
directory, filename = os.path.split(filepath)
filename_no_ext, ext = os.path.splitext(filename)
To re-make a filepath:
new_filepath = os.path.join(directory, new_filename)

Have 3 GPS source (these inherit from SensorBase too)
    - Local GPS (like remote GPS but local)
    - Test GPS (uses file)
    - Remote GPS (has IP address for GPS from another computer)
    
Every computer has a GPS Server sensor that gets info from it.


