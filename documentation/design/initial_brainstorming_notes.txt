Drawbacks of PISC:
   - Not straightforward to have sensor drivers written in another language.
   - Have to lookup sensor settings for each sensor type and units.  Not really built into the system.
   - All text feedback is merged into one stream.
   - Can't send commands to sensor from GUI (e..g. trigger camera, pause, etc).
   - Impossible to restart a sensor (if it crashes or fails to startup) without restarting everything.
   - Can't run/use sensors drivers independent from larger system.

Major changes:

Sensors are each contained in module that can either be started in a process or a thread (ZMQ).   They all have a common interface for sending messages... UTC timestamps are also sent with the sys time since sensors have to be on the same computer.  Usually only break into a separate process if need to use a different language.   All sensors would have the following output interfaces:
   
data stream - publish subscribe
message stream - for text output
status stream - started / stopped / paused / good / bad

And an input stream of:
time stream -> utc + sys time stamp
command stream -> start stop pause / etc

The GUI would be have two columns.  Left column is a list of sensor names with a large colored box next to it that shows status of sensor.  

If click on one of these sensor the right column shows three sections.
  1) Settings - passed to sensor on startup (these should be grayed out once started)
       - Name, sensor_type, port, baud,  etc.  These are just generated line edits.
       - Sensor type should be  a dropdown loaded from meta file.
  2) Message view - shows text output 
  2) Data View - shows live stream of sensor data (make this a button)
  3) Command buttons - Start / stop / pause
  4) Custom command buttons - trigger

Use YAML for config files.  Make sure they're versioned and each sensor is versioned.

At the top of the whole window there's a large menu button which makes the right hand column have the following stuff:
  1) Load file - loads a new config file. If theres already sensors loaded should ask if want to append to them.
  2) Save file - saves the current sensor settings to a file.
  3) Open session - this opens the sensors
  4) Close session
  5) Start collection 
  5) Pause collection
  6) Resume collection
  7) Add Sensor 
  8) Delete sensor
  3) Output directory - where to save the contents to 
  4) Open directory 

If user clicks start on a single sensor before a session has been started then warn that this will start a new session.  

Each sensor as an output directory where it logs data to using it's name as the file.

The GPS gets treated as a normal sensor.  Either have a normal 'gps' type and a 'remote_gps' type that is a GPS client.   In either case can build datalogging directly into these.    

The GUI creates a new SensorController.

Try to treat GPS as a normal sensor but with an IP address.  This is the only one required.  

remote GPS should have an extra command for running latency check.

Start all sensors off in a paused state until verify that all sensors started up ok.

For each sensor need to know:
Version number
Thread or process
Name and Type and Settings

Have a single sensor meta YAML file that has for each sensor type.
Setting names - data types
Extra command names
Data stream names, units and types
