Overall design
•	Every time sensor changes it sends out a signal that it changes and GUI completely reloads (status, fields, messages)
•	GUI sends changes to sensors using generic settingChanged() or handleCommand()
•	All sensors (in the app) have a unique ID from 0 – n.
•	Once a sensor is ‘opened’ its settings can’t be changed from GUI.
•	If a sensor changes type then this will destroy the original sensor and create a new one with the desired type and have the same name as before.
•	Sensor controller will enforce that all sensors have a unique name.  If it doesn’t then it will silently change one.  Sensor names can’t be empty strings.
•	Don’t actually create any real sensors until user clicks “start session”
•	GUI saves off ‘dialog’ for each sensor and reloads it if it has one... otherwise it makes one.

Use case – User want to add a new sensor to GUI
1.	In menu user clicks ‘Add Sensor’ button.
2.	View tell presenter to add a new sensor with some default sensor type.
3.	The MainPresenter tells the SensorController to create a new sensor.
4.	The SensorController then notifies MainPresenter that a change occurred with a sensor (and passes it the new sensor).   
5.	The Main presenter then calls view.updateSensor() which will check if the sensor ID already has a layout… which it won’t so the view will create one using all the sensor info.  Along with the layout the form will also create a button for the new sensor.  
6.	The Main presenter then calls view.showSensor() and passes it the ID to show the one it just created. 

Use case – User wants to trigger camera from GUI
1. User clicks on camera sensor button to show SensorViewer.
2. This looks up in a dictionary what sensor id is associated with pressed button.
3. View calls it's own show_sensor() button using the id it found.
4. User clicks 'trigger' button.
5. Callback in View uses button text as the command and does something like self.presenter.handle_sensor_command(button_text)
6. Presenter tells controller which finds correct sensor client to actually send the command.
7. TODO - handle if message can't be sent.

Use case – Sensor sends out new text message which should appear in GUI.
1. Sensor calls self.send_message() which is in SensorBase
2. A callback gets called in sensor client which tells presenter using handle_new_message_from_sensor()
3. Presenter tells view using append_sensor_message() and the active sensor id.
4. View looks up layout for sensor and adds it to the append message.

Use case – Sensor status goes from good to bad.
1. Sensor calls update_heath() 
2. A callback gets called in sensor client which tells present using handle_sensor_changed()

Use case – User loads a new configuration file
1) User clicks 'load sensor setup' button.
2) A file selection dialog is shown and if the user picks a file then tells presenter using load_sensor_setup()
...

Use case - User wants to connect to sensors.
1) User clicks connect sensors
2) View calls presenter.connect_all_sensors() which calls client.connect()
3) Client either starts new process or thread and either way passes it the port number and waits for a connection.
   The sensor should back 3 new ports to the client, which is what it subscribes to.  The connection that's already
   opened is used for time/commands.
   
Use case - GPS sends back position data and when sensor client gets it 

Use case - User wants to use a remote GPS between multiple computers.
 1) Sensor client 

Use case – User wants to change sensor name
1) In SensorViewer user changes 

Use case – User wants to change sensor type


